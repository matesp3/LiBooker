@page "/publications"
@inject PublicationClient PublicationClient
@implements IDisposable

<h3>Publications</h3>

@if (this.isLoading)
{
    <p><em>Loading publications...</em></p>
}
else if (!string.IsNullOrEmpty(this.error))
{
    <div class="alert alert-danger">@error</div>
}
else if (this.publications is null || this.publications.Count == 0)
{
    <p>No publications found.</p>
}
else
{
    @if (this.isLoadingImages)
    {
        <div class="alert alert-info">Loading images... (@imagesLoaded / @publications.Count)</div>
    }

    <div class="row">
        @foreach (var pub in this.publications)
        {
            <div class="col-md-4 mb-3">
                <div class="card">
                    @if (pub.Image != null && pub.Image.Length > 0)
                    {
                        <img src="@GetImageDataUrl(pub.Image)" class="card-img-top" alt="@pub.Title" />
                    }
                    else
                    {
                        <div class="card-img-top bg-secondary text-white d-flex align-items-center justify-content-center" style="height: 200px;">
                            <span>Loading image...</span>
                        </div>
                    }
                    <div class="card-body">
                        <h5 class="card-title">@pub.Title</h5>
                        <p class="card-text">
                            <strong>Author:</strong> @pub.Author<br/>
                            <strong>Publisher:</strong> @pub.Publication<br/>
                            <strong>Year:</strong> @pub.Year
                        </p>
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="mt-3">
        <button class="btn btn-primary" @onclick="PreviousPage" disabled="@(this.currentPage <= 1 || this.isLoading)">Previous</button>
        <span class="mx-3">Page @currentPage</span>
        <button class="btn btn-primary" @onclick="NextPage" disabled="@(this.isLoading || this.publications.Count < this.pageSize)">Next</button>
    </div>
}

@code {
    private const int ImageBatchSize = 5; // Load 5 images at a time
    private bool isLoading;
    private bool isLoadingImages;
    private int currentPage = 1;
    private int imagesLoaded;
    private int pageSize = 15;
    private string? error = null;
    private CancellationTokenSource? cts = null;
    private List<PublicationMainInfo>? publications;

    protected override async Task OnInitializedAsync()
    {
        await LoadPublications();
    }

    private async Task LoadPublications()
    {
        this.cts?.Cancel(); // if there is an ongoing load, cancel it
        this.cts?.Dispose();
        // ---------------- reset ----------------
        this.cts = new CancellationTokenSource();
        this.isLoading = true;
        this.error = null;
        this.imagesLoaded = 0;
        // ---------------- new request ----------------
        // Step 1: Load publications WITHOUT images (fast - for better UX)
        var result = await PublicationClient.GetAllAsync(this.currentPage, this.pageSize, this.cts.Token);

        this.isLoading = false;

        if (result.IsSuccess)
        {
            this.publications = result.Data;
            StateHasChanged(); // Update UI immediately with metadata

            // Step 2: Load images progressively in batches
            if (this.publications != null && this.publications.Count > 0)
            {
                _ = LoadImagesProgressively(this.cts.Token); // Fire and forget
            }
        }
        else
        {
            this.error = result.Error ?? "Unknown error";
        }
    }

    private async Task LoadImagesProgressively(CancellationToken ct)
    {
        if (this.publications == null || this.publications.Count == 0) return;
        
        this.isLoadingImages = true;
        StateHasChanged();

        try
        {
            // Load images in batches of ImageBatchSize
            for (int i = 0; i < this.publications.Count; i += ImageBatchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = publications.Skip(i).Take(ImageBatchSize).ToList();
                var ids = batch.Select(p => p.ImageId).ToList();

                var imageResult = await PublicationClient.GetImagesAsync(ids, ct); // TODO

                if (imageResult.IsSuccess && imageResult.Data != null)
                {
                    var pairs = imageResult.Data.ToDictionary(data => data.ImageId, data => data.ImageData);
                    Console.WriteLine($"Loaded batch of {pairs.Count} images.");
                     // Update publications with loaded images
                    foreach (var pub in batch)
                    {
                        if (pairs.TryGetValue(pub.ImageId, out var imageData))
                        {
                            pub.Image = imageData;
                            this.imagesLoaded++;
                        }
                    }

                    StateHasChanged(); // Update UI after each batch
                }

                // Small delay between batches to avoid overwhelming the server
                await Task.Delay(100, ct);
            }
        }
        catch (OperationCanceledException)
        {
            // User navigated away or cancelled
        }
        finally
        {
            this.isLoadingImages = false;
            StateHasChanged();
        }
    }

    private string GetImageDataUrl(byte[] imageData)
    {
        if (imageData == null || imageData.Length == 0)
            return string.Empty;

        var base64 = Convert.ToBase64String(imageData);
        return $"data:image/jpeg;base64,{base64}";
    }

    private async Task NextPage()
    {
        this.currentPage++;
        await LoadPublications();
    }

    private async Task PreviousPage()
    {
        if (this.currentPage > 1)
        {
            this.currentPage--;
            await LoadPublications();
        }
    }

    public void Dispose()
    {
        this.cts?.Cancel();
        this.cts?.Dispose();
    }
}