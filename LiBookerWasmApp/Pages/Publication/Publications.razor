@* @page "/publications"
@inject LiBooker.Blazor.Client.Services.PublicationClient PublicationClient
@implements IDisposable

<h3>Publications</h3>

@if (isLoading)
{
    <p><em>Loading publications...</em></p>
}
else if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">@error</div>
}
else if (publications is null || publications.Count == 0)
{
    <p>No publications found.</p>
}
else
{
    @if (isLoadingImages)
    {
        <div class="alert alert-info">Loading images... (@imagesLoaded / @publications.Count)</div>
    }

    <div class="row">
        @foreach (var pub in publications)
        {
            <div class="col-md-4 mb-3">
                <div class="card">
                    @if (pub.Image != null && pub.Image.Length > 0)
                    {
                        <img src="@GetImageDataUrl(pub.Image)" class="card-img-top" alt="@pub.Title" />
                    }
                    else
                    {
                        <div class="card-img-top bg-secondary text-white d-flex align-items-center justify-content-center" style="height: 200px;">
                            <span>Loading image...</span>
                        </div>
                    }
                    <div class="card-body">
                        <h5 class="card-title">@pub.Title</h5>
                        <p class="card-text">
                            <strong>Author:</strong> @pub.Author<br/>
                            <strong>Publisher:</strong> @pub.Publication<br/>
                            <strong>Year:</strong> @pub.Year
                        </p>
                    </div>
                </div>
            </div>
        }
    </div>

    <div class="mt-3">
        <button class="btn btn-primary" @onclick="PreviousPage" disabled="@(currentPage <= 1 || isLoading)">Previous</button>
        <span class="mx-3">Page @currentPage</span>
        <button class="btn btn-primary" @onclick="NextPage" disabled="@(isLoading || publications.Count < pageSize)">Next</button>
    </div>
}

@code {
    private List<PublicationMainInfo>? publications;
    private bool isLoading;
    private bool isLoadingImages;
    private int imagesLoaded;
    private string? error;
    private CancellationTokenSource? cts;
    private int currentPage = 1;
    private int pageSize = 15;
    private const int ImageBatchSize = 5; // Load 5 images at a time

    protected override async Task OnInitializedAsync()
    {
        await LoadPublications();
    }

    private async Task LoadPublications()
    {
        cts?.Cancel();
        cts?.Dispose();
        cts = new CancellationTokenSource();

        isLoading = true;
        error = null;
        imagesLoaded = 0;

        // Step 1: Load publications WITHOUT images (fast)
        var result = await PublicationClient.GetAllAsync(currentPage, pageSize, cts.Token);

        isLoading = false;

        if (result.IsSuccess)
        {
            publications = result.Data;
            StateHasChanged(); // Update UI immediately with metadata

            // Step 2: Load images progressively in batches
            if (publications != null && publications.Count > 0)
            {
                _ = LoadImagesProgressively(cts.Token); // Fire and forget
            }
        }
        else
        {
            error = result.Error ?? "Unknown error";
        }
    }

    private async Task LoadImagesProgressively(CancellationToken ct)
    {
        if (publications == null || publications.Count == 0) return;

        isLoadingImages = true;
        StateHasChanged();

        try
        {
            // Load images in batches of ImageBatchSize
            for (int i = 0; i < publications.Count; i += ImageBatchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = publications.Skip(i).Take(ImageBatchSize).ToList();
                var ids = batch.Select(p => p.Id).ToList();

                var imageResult = await PublicationClient.GetImagesByIdsAsync(ids, ct);

                if (imageResult.IsSuccess && imageResult.Data != null)
                {
                    // Update publications with loaded images
                    foreach (var pub in batch)
                    {
                        if (imageResult.Data.TryGetValue(pub.Id, out var imageData))
                        {
                            pub.Image = imageData;
                            imagesLoaded++;
                        }
                    }

                    StateHasChanged(); // Update UI after each batch
                }

                // Small delay between batches to avoid overwhelming the server
                await Task.Delay(100, ct);
            }
        }
        catch (OperationCanceledException)
        {
            // User navigated away or cancelled
        }
        finally
        {
            isLoadingImages = false;
            StateHasChanged();
        }
    }

    private string GetImageDataUrl(byte[] imageData)
    {
        if (imageData == null || imageData.Length == 0)
            return string.Empty;

        var base64 = Convert.ToBase64String(imageData);
        return $"data:image/jpeg;base64,{base64}";
    }

    private async Task NextPage()
    {
        currentPage++;
        await LoadPublications();
    }

    private async Task PreviousPage()
    {
        if (currentPage > 1)
        {
            currentPage--;
            await LoadPublications();
        }
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
    }
} *@